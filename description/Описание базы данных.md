# Выбор баз данных
В качестве базы данных будет использована СУБД PostgreSQL.
Для хранения кеша будет использоваться Redis, как стандарт в области. 
Для работы с логами будет использована система управления логами "Elasticsearch". 
## PostgreSQL 

PostgreSQL – это мощная реляционная база данных, идеально подходящая для хранения структурированных данных с четкими отношениями между таблицами. В данном проекте PostgreSQL будет использоваться для хранения следующих данных:

- Группы товаров
- Категории и подкатегории
- Товары
- Пользователи
- Склады
- Города
- Корзины
- Заказы

### Анализ
#### Преимущества:

1. **Реляционная структура данных**:
   - PostgreSQL поддерживает сложные реляционные структуры, что позволяет создавать связи между таблицами и поддерживать целостность данных.
   - Это делает PostgreSQL идеальным для хранения данных о пользователях, товарах, заказах, категориях и других сущностях с четко определенными отношениями.

2. **Поддержка ACID-транзакций**:
   - PostgreSQL гарантирует атомарность, согласованность, изолированность и долговечность (ACID), что важно для обеспечения надежности и согласованности данных.
   - Особенно важно для финансовых операций, таких как заказы и платежи.

3. **Расширенные возможности запросов**:
   - Поддержка сложных SQL-запросов, подзапросов, оконных функций и других расширенных возможностей SQL.
   - Это позволяет эффективно выполнять сложные аналитические запросы и агрегаты.

4. **Безопасность данных**:
   - Встроенные механизмы аутентификации и авторизации.
   - Поддержка шифрования данных на уровне колонок и таблиц.

5. **Масштабируемость**:
   - Поддержка масштабирования на уровне чтения через репликацию.
   - Возможность горизонтального масштабирования с использованием шардинга.

#### Недостатки:
1. **Сложность настройки и управления**:
   - Требует квалифицированного администрирования для настройки и оптимизации.
   - Более сложное управление по сравнению с NoSQL базами данных.

2. **Производительность на больших объемах данных**:
   - Хотя PostgreSQL хорошо масштабируется, на очень больших объемах данных (петабайты) могут возникнуть проблемы с производительностью.
   - Вертикальное масштабирование рано или поздно доходит до своих пределов и становится необходимым расширяться горизонтально, но это приводит к потере ACID операций в их поставляемом формате, из-за чего возникают риски нарушения хранения данных.

#### Заключение
PostgreSQL обеспечивает надежное и согласованное хранение структурированных данных, что идеально подходит для основной информации о пользователях, товарах, заказах и т.д., то есть для наших нужд. 
В нашем приложении также будет использовать реплицирование данных, на всякий случай. 
### Структура таблиц в PostgreSQL

1. **Таблица `Users` (Пользователи)**
   ```postgresql
   CREATE TABLE Users (
       user_id SERIAL PRIMARY KEY,
       email VARCHAR(100) UNIQUE NOT NULL,
       password_hash VARCHAR(255) NOT NULL,
       roles VARCHAR[],
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );
   ```

2. **Таблица `Groups` (Группы товаров)**
   ```postgresql
   CREATE TABLE Groups (
       group_id SERIAL PRIMARY KEY,
       image_url TEXT,
       name VARCHAR(100) NOT NULL
   );
   ```

3. **Таблица `Categories` (Категории)**
   ```postgresql
   CREATE TABLE Categories (
       category_id SERIAL PRIMARY KEY,
       image_url TEXT,
       category_name VARCHAR(100) NOT NULL,
       group_id INT REFERENCES Groups(group_id)
   );
   ```

4. **Таблица `Subcategories` (Подкатегории)**
   ```postgresql
   CREATE TABLE Subcategories (
       subcategory_id SERIAL PRIMARY KEY,
       image_url TEXT,
       subcategory_name VARCHAR(100) NOT NULL,
       category_id INT REFERENCES Categories(category_id)
   );
   ```

5. **Таблица `Products` (Товары)**
   ```postgresql
   CREATE TABLE Products (
       product_id SERIAL PRIMARY KEY,
       product_name VARCHAR(100) NOT NULL,
       image_url TEXT,
       parameters JSONB,
       price DECIMAL(10, 2) NOT NULL,
       subcategory_id INT REFERENCES Subcategories(subcategory_id),
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );
   ```

6. **Таблица `Warehouses` (Склады)**
   ```postgresql
   CREATE TABLE Warehouses (
       warehouse_id SERIAL PRIMARY KEY,
       city_id INT REFERENCES Cities(city_id),
       product_id INT REFERENCES Products(product_id),
       quantity INT NOT NULL
   );
   ```

7. **Таблица `Cities` (Города)**
   ```postgresql
   CREATE TABLE Cities (
       city_id SERIAL PRIMARY KEY,
       city_name VARCHAR(100) NOT NULL
   );
   ```

8. **Таблица `Carts` (Корзины)**
   ```postgresql
   CREATE TABLE Carts (
       cart_id SERIAL PRIMARY KEY,
       user_id INT REFERENCES Users(user_id),
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );
   ```

9. **Таблица `CartItems` (Товары в корзине)**
```postgresql
   CREATE TABLE CartItems (
       cart_item_id SERIAL PRIMARY KEY,
       cart_id INT REFERENCES Carts(cart_id),
       product_id INT REFERENCES Products(product_id),
       quantity INT NOT NULL
   );
   ```

10. **Таблица `Orders` (Заказы)**
	```postgresql
    CREATE TABLE Orders (
        order_id SERIAL PRIMARY KEY,
        user_id INT REFERENCES Users(user_id),
        status VARCHAR(50) NOT NULL,
        total_price DECIMAL(10, 2) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    ```

11. **Таблица `OrderItems` (Товары в заказе)**
    ```postgresql
    CREATE TABLE OrderItems (
        order_item_id SERIAL PRIMARY KEY,
        order_id INT REFERENCES Orders(order_id),
        product_id INT REFERENCES Products(product_id),
        quantity INT NOT NULL
    );
    ```

### Хранение медиаконтента
Медиаконтент, в нашем приложении это изображения, будут храниться в базе данных, в полях ```image_url```. Согласно названию поля, они будут храниться в виде URL ссылки, которую приложение будет получать от **YOS** (Yandex Object Storage). И соответственно обращаясь в YOS с ссылкой, в ответ она нам выдаст изображение. Такое хранение медиаконтента позволит освободить базу данных от хранения таких тяжелых файлов как изображения, благодаря чему запросы будут проходить быстрее, чем если бы изображения непосредственно хранились в базе.

## Redis: Хранение кэша

Redis – это высокопроизводительная база данных в памяти, используемая для кэширования данных, что позволяет значительно ускорить доступ к часто запрашиваемой информации. В приложении она будет использоваться для того, чтобы снять часть нагрузки с базы данных и самые необходимые и часто используемые данные можно было быстро достать из оперативной памяти, где Redis организует хранилище. 
### Анализ
#### Преимущества:
1. **Высокая производительность**:
   - Redis работает в памяти, что обеспечивает очень высокую скорость чтения и записи.
   - Идеально подходит для кэширования данных и выполнения операций с низкой задержкой.

2. **Простота использования**:
   - Простая и понятная модель данных (ключ-значение).
   - Легкость интеграции и использования в приложениях.

3. **Поддержка различных структур данных**:
   - Помимо ключ-значение, Redis поддерживает списки, множества, хеши, отсортированные множества и другие структуры данных.
   - Это позволяет использовать Redis для широкого спектра задач.

4. **Масштабируемость**:
   - Поддержка горизонтального масштабирования и шардинга.
   - Возможность создания кластеров для увеличения производительности и отказоустойчивости.

5. **Поддержка Pub/Sub и TTL**:
   - Возможность использования механизмов публикации/подписки (Pub/Sub) для реализации систем уведомлений.
   - Поддержка TTL (время жизни) для автоматического удаления устаревших данных.

#### Недостатки:
1. **Ограниченность объема данных**:
   - Так как Redis хранит данные в памяти, объем данных ограничен объемом доступной оперативной памяти.
   - Хотя можно использовать механизм сброса на диск (RDB, AOF), это не подходит для хранения больших объемов данных, как в PostgreSQL.

2. **Отсутствие реляционной модели**:
   - Redis не поддерживает сложные реляционные структуры и транзакции ACID, что ограничивает его использование для задач, требующих сложной логики и целостности данных.

3. **Управление данными**:
   - Необходимо внимательно следить за использованием памяти, так как переполнение памяти может привести к сбоям или снижению производительности.
   - Необходимо настраивать механизмы сохранения данных на диск для предотвращения потерь данных в случае отказа.